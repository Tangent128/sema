#!./sema

local running = true

local c = 0

function command.incr(...)
	c = c + 1
	reply(c, ...)
	local status = run{"sleep", 1}
	reply(status)
end

function command.lsenv()
	for name in DEBUG.pairs(DEBUG.api) do
		reply(name)
	end
	reply "====="
	for name in DEBUG.pairs(_ENV) do
		reply(name)
	end
end

function command.gc()
	--for x in DEBUG.pairs(DEBUG.queue.getActive().script.threads) do
	--DEBUG.print(x)
	--end
	DEBUG.collectgarbage("collect")
end

function command.quit()
	running = false
	signal(nil, SIGKILL)
end

function command.down()
	setEvent("up", false)
	-- sleep doesn't die easily...
	signal(nil, SIGKILL)
end

local bsleep = parallel(function()
	--DEBUG.print"bsleep"
	local i = 1
	while true do
		i = i + 1
		waitEvent "breset"
		run {
			"sleep", DEBUG.tostring(i)
		}
		DEBUG.print "bsleep!"
	end
end)

function command.breset()
	signal(bsleep, SIGKILL)
	triggerEvent"breset"
end

function command.md5()
	local p = pipe()
	local i = p.input
	local o = p.output

	-- inherently hacky and ill-advised, but
	-- should work after a GC cycle closes the
	-- pipe fds in the sema process

	-- [[
	parallel(function()
		run {
			stdin = o,
			"md5sum"
		}
	end)
	--]]

	parallel(function()
		run {
			stdout = i,
			cmd"echo 1234567"
		}
	end)
end

local catPipe = pipe()
local cat = parallel(function()
	run {
		stdin = catPipe.output,
		cmd"cat -n"
	}
end)

function command.cram(text)
	catPipe.input:writeln(text)
end

function command.name()
	reply(scriptName())
end

while running do

runIfUp{
	"sleep", "300"
}

DEBUG.print "looop!"

end

--DEBUG.print "done!"

